<h1>First</h1>
<p><br/><br/><br/>每周上課內容</p>
<p>W7: (1.)設定 OBS、Youtube直播 (2.)小組討論設定、建立網站<br/>W8: 線上課程、小組線上討論<br/>W10: 利用 Python 程式讀取學生的座號與修課成績<br/>W11: (1.)<span>說明如何將Python放入虛擬主機中</span>(2.)利用ssh來push倉儲<br/>W12: 安裝虛擬主機<br/>W13: 建立一台實體主機<br/>W14: 編譯NGINX<br/>W15: (1.)利用Pypdf2切割pdf檔(2.)利用HxD編修pip.exe<br/>W16:<br/>W17:</p><h1>上課內容整理</h1>
<h2>W10</h2>
<h3>Python程式</h3>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">import csv
  
# read student list
filename = 'D:/1a/1alist.txt'
with open(filename, encoding="utf-8") as f:
    content = f.readlines()
    student = [x.strip() for x in content] 
#print(content)
#print(student)
  
# Timestamp, email, ????, url, score, desp, memo
# 0, 1, 2, 3, 4, 5, 6
#total = 0
 
all = {}
with open('D:/1a/1a.csv', encoding="utf-8") as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
      
    line_count = 0
    for row in csv_reader:
        if line_count == 0:
            #print(f'Column names are {", ".join(row)}')
            line_count += 1
        else:
            student_num = row[1].split("@")[0]
            #print(student_num)
            student_score = row[4]
            #print(student_score)
            try:
                all.update({student_num: student_score})
            except:
                all.update({student_num: "error"})
            #print(f'\t{row[0]} works in the {row[1]} department, and was born in {row[2]}.')
            #print(f'\t{row[4]}')
            #total += int(row[4])
            line_count += 1
#print(all)
#print(student)
 
for i in student:
      
    #if i in all:
        #pass
    #else:
        #print(str(i))
      
    try:
        print(i + "\t" + all[i])
    except:
        print(i + "\t60")
 
  
    #print(f'Processed {line_count} lines.')
    #print("??=" + str(total/line_count))</pre>
<p><strong>Flask程式:</strong></p>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask
  
app = Flask(__name__)
  
@app.route('/') 
def hello_world():
    return 'Hello, From Flask!'
  
if __name__== '__main__': 
    app.run()</pre><h3>CSV</h3>
<p>逗號分隔值 (<span>Comma-Separated Values</span>) 其檔案以<strong>純文字</strong><span>形式儲存表格</span><span>資料。</span></p>
<p><span>CSV檔案由任意數目的記錄<span>組成，記錄間以換行符號分隔；每條記錄由欄位</span><span>組成，欄位間的分隔符是其它字元或字串，最常見的就是逗號。</span></span></p>
<p></p><h2>W14</h2>
<h3>MBR與GPT</h3>
<p><span><strong>MBR:</strong> Master Boot Record 主開機記錄 </span><span><br/>[啟動系統:<strong>BIOS</strong>]<br/>只適用於最大容量<span style="color: #000000;"><strong><span style="background-color: #ffffff;">2TB的硬碟</span></strong></span>，如果使用容量更大的硬碟，則無法識別，同時MBR也只支援最大4個主分割區。<br/>現今的社會都是大容量的硬碟，所以使用MBR會被侷限。<br/><br/><strong>GPT:</strong> GUID Partition Table (俗稱:GUID磁碟分割表格)</span><br/><span>[啟動系統:</span><strong>UEIF</strong><span>]</span><br/>GPT逐漸取代掉MBR，GPT使用了更現代的技術取代老舊的MBR磁碟分割表格。<br/>GPT的推出與 <span style="color: #ff0000;"><strong>UEFI</strong></span> 是相輔相成的，<span>想要<strong><span style="color: #000000;">使用GPT</span></strong>就必須是<span style="color: #000000;"><strong>UEFI的環境</strong></span></span>。</p>
<p><strong><span style="color: #0000ff;">優勢: 1.</span></strong><span style="color: #0000ff;"><span style="color: #000000;">突破了<strong>MBR</strong>最大只支援<strong>2T</strong>硬碟的限制<br/>         <strong><span style="color: #0000ff;"> 2.</span></strong>允許無限數量的分割區不必創建擴展分區即可使其工作</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">在<strong>MBR</strong>的磁碟上，<span>分割區和引導資料都存儲在<strong><span style="color: #ff0000;">同一個地方</span></strong>。如果資料被<span style="color: #ff0000;"><strong>覆蓋</strong></span>或<strong><span style="color: #ff0000;">損壞</span></strong>，就無法電將腦啟動。</span><br/>相較之下，<strong>GPT</strong>磁碟上會儲存<strong><span style="color: #ff0000;">多個副本<span style="color: #000000;">，</span></span></strong><span style="color: #ff0000;"><span style="color: #000000;">使其更加穩定、安全，並且可以在<strong>資料損壞</strong>下進行<strong>修復</strong>。</span></span></span></span></p>
<h3>BIOS與UEFI</h3>
<p><span style="color: #000000;"><strong>BIOS :</strong> </span><span>Basic Input Output System  基本輸入輸出系統</span></p>
<p><span>BIOS是位於電腦主機板上的晶片中的低級軟體。電腦啟動時， BIOS會喚醒電腦的硬體元件，確保它們正常運行。近幾年BIOS就沒有太大的技術改革，而且一直局限於<span style="color: #000000;"><strong>2TB</strong></span>的磁碟，而且啟動時僅有的<span style="color: #000000;"><strong>1MB執行空間</strong></span>，導致啟動時間被拉長。</span></p>
<p><br/><strong><span style="color: #000000;">UEFI :</span> </strong>Unified Extensible Firmware Interface  <span>統一可延伸韌體介面</span> <br/>[UEFI就像<span style="color: #000000;"><strong>進階版的BIOS</strong></span>，但不能稱它為BIOS]</p>
<p><span>UEFI是一種新的主機板引導項，它不同於傳統BIOS的開機流程，這種介面可以讓作業系統自動從預啟動的操作環境中載入，加快作業系統的速度。</span><br/>UEFI帶來的<span style="color: #000000;"><strong>最大改變就是<span style="color: #ff0000;">圖形化</span>、<span style="color: #ff0000;">可滑鼠操作的介面</span></strong></span></p>
<p><span style="color: #0000ff;"><strong>優勢: </strong><span style="color: #000000;"><span style="color: #0000ff;">1.</span>  <strong>有更強的安全性</strong></span></span><br/><span style="color: #0000ff;">          2.</span>  <span style="color: #000000;"><strong>啟動速度更快</strong></span><br/><span style="color: #0000ff;">          3.</span>  <span style="color: #000000;"><strong>支援容量更大</strong></span></p>
<h2>W16</h2>
<h3>何謂wsgi</h3>
<p>WSGI (<span>Web Server Gateway Interface</span>) :</p>
<p><span>WSGI 為一個Gateway，也就是閘道器。閘道器的作用就是在協議之間進行轉換。</span></p>
<p><span>WSGI <span>是一個web元件的介面防範，wsgi將web元件分為三類：<strong>web伺服器、web中介軟體、web應用程式。</strong>作為 Web 伺服器與 Web 應用程式或應用框架之間的一種低階別的介面，以提升可移植 Web 應用開發的共同點。</span></span></p>
<p><span>WSGI有兩方：<strong>伺服器</strong>或<strong>閘道器</strong>一方，以及<strong>應用程式</strong>或<strong>應用框架</strong>一方。服務方呼叫應用方，提供環境資訊，以及一個回撥函式，並接收Web內容作為返回值。</span></p>
<h1>錯誤修正</h1>
<h2>命令列無法使用pip下載程式</h2>
<p>我們當初是從 get-pip.py 下載pip，但下載後的<strong>pip install</strong>中的二位元檔的<strong>Python</strong>是<strong>windows</strong>版的(python<strong>w</strong>.exe)，所以當我們在命令列使用Python執行pip它才不會有反應。</p>
<p>我們利用 <strong>Binary Editor</strong> (二位元編輯器) 來更改pip.exe中的pythonw.exe改為python.exe。</p>
<p><img alt="" height="363" src="/images/1591932301485.jpg" width="564"/></p>
<p></p>